# Аудит MRNode (A+B)

Цей файл — накопичувальний звіт аудиту проєкту **MRNode**.

- Формат: українською, з пріоритетами (P0/P1/P2), конкретними посиланнями на файли.
- Мета: щоб після завершення аудиту можна було прочитати один файл і отримати повну картину **функціоналу, переваг/недоліків, ризиків і плану покращень**.

---

## 0) Коротке резюме (Executive Summary)

MRNode — Next.js (App Router) застосунок для перегляду, пошуку, аналітики та синхронізації митних декларацій з підтримкою мультикомпанійності.

Сильні сторони:
- Хороша доменна модель: `Declaration` + `DeclarationSummary` + `DeclarationHsCode`.
- Мультикомпанійність закладена системно (`UserCompany`, `activeCompanyId`).
- Логіка часто винесена в `src/actions/*` (зручно підтримувати).

Критичні ризики (виправити першими):
- Fallback `AUTH_SECRET` у коді (можливий запуск продакшну з дефолтним секретом).
- Fallback `DATABASE_URL` у коді (ризик неправильного підключення/сек’юрності).

---

## 1) Продукт (A): функціонал та цінність

### 1.1 Основний функціонал (знайдено у коді/схемі)
- **Авторизація**: NextAuth Credentials (email/password), JWT-сесія.
- **Користувачі та ролі**: `User.role` (`ADMIN`, `BROKER`, `MANAGER`).
- **Мультикомпанійність**:
  - many-to-many `UserCompany` з ролями доступу (`OWNER`, `MEMBER`, `VIEWER`).
  - `activeCompanyId` як швидкий контекст.
- **Декларації**:
  - `Declaration.xmlData` (важкі дані)
  - `DeclarationSummary` (кеш/денормалізація для фільтрів/аналітики)
  - `DeclarationHsCode` (УКТЗЕД)
- **Синхронізація**:
  - `SyncHistory`, `SyncJob`, `SyncJobError` (облік процесу, прогресу, помилок)
- **Курси валют**: `ExchangeRate` + механізм синку.
- **Нотифікації**: модель `Notification`.

### 1.2 UX/Продуктові сильні сторони
- Архітектура даних дозволяє масштабувати перегляд/фільтрацію без постійної роботи з “важким” XML.

### 1.3 UX/Продуктові слабкі сторони (поточні)
- `README.md` — шаблонний (create-next-app), не описує продукт, ENV, деплой.
- У корені багато великих/службових файлів (дамп, txt) — заважає DX (в т.ч. git-команди можуть зависати).

---

## 2) Система/код (B): архітектура, якість, безпека

### 2.1 Стек
- Next.js `16.1.1` (App Router)
- React `19`
- Prisma `5.22`
- NextAuth `5 beta`
- TailwindCSS `4`

### 2.2 Архітектура (як влаштовано)
- Серверні дії: `src/actions/*`.
- Auth:
  - `src/auth.ts`, `src/auth.config.ts`, `src/middleware.ts`.
- Prisma DB клієнт: `src/lib/db.ts`.
- Dashboard:
  - `src/app/dashboard/layout.tsx` серверно тягне `getUserProfile()`.

### 2.3 Ризики безпеки / продакшн (P0)

#### P0-1: Дефолтний AUTH secret
Файл: `src/auth.config.ts`
- `secret: process.env.AUTH_SECRET || "secret_key_123456789"`

Ризик:
- Якщо `AUTH_SECRET` не заданий у проді (Render), авторизація може працювати з відомим дефолтом.

Рекомендація:
- Прибрати fallback.
- У проді падати з чіткою помилкою, якщо `AUTH_SECRET` не заданий.

#### P0-2: Fallback DATABASE_URL у коді
Файл: `src/lib/db.ts`
- `process.env.DATABASE_URL` (повинен бути заданий)

Ризик:
- Якщо `DATABASE_URL` не заданий/зламаний, апка може працювати некоректно або підключитися не туди (якщо є fallback/дефолт).

Рекомендація:
- Прибрати будь-які fallback/дефолтні значення і вимагати `DATABASE_URL` завжди (включно з dev).

### 2.4 Середні ризики (P1)
- `src/app/layout.tsx`: `<html lang="en">` при україномовному UI (краще `uk`).

---

## 3) Git/деплой/операційні процеси

- Деплой: **Render тягне з `main`**.
- Прийнятий процес на майбутнє: **прямий commit+push у `main` без GitHub UI**.
- Завжди **уникати `git add .`**, бо в репо з’являються великі untracked файли.

---

## 4) План подальшого аудиту (що ще аналізую далі)

Наступні області для детального аналізу:
- `src/actions/sync.ts` (синхронізація, retries, обробка помилок, продуктивність)
- `src/actions/companies.ts` (доступи, інвайти, аудити, налаштування)
- `src/actions/analytics.ts` (агрегації, важкі запити, кеші)
- `src/app/api/*` (особливо `debug`/`admin` маршрути)
- `src/app/dashboard/archive/*` (повний шлях: UI → server actions → DB)

---

## 6) Додаткові висновки (поглиблений аналіз)

### 6.1 Синхронізація: `src/actions/sync.ts`

#### Сильні сторони
- Є **явна рольова перевірка** перед синхронізацією: тільки `OWNER`/`MEMBER`.
- Використовується **`activeCompanyId`** (через `getActiveCompanyFullAccess`/`getActiveCompanyWithAccess`).
- `customsToken` зберігається в компанії та **розшифровується** через `@/lib/crypto` перед запитами.
- Є увага до продуктивності:
  - коментарі/обмеження “не тягнути `xmlData`” де не потрібно
  - `logMemory()` / `FORCE_GC` для діагностики OOM
  - throttling: `await new Promise(resolve => setTimeout(resolve, 1000))` між запитами (rate limit)
- Розбиття періоду та обмеження:
  - 60.1 не дозволяє більше **45 днів** (обмеження API митниці)
  - обмеження глибини історії **1095 днів** (3 роки)

#### Слабкі сторони / техборг
- **Дублювання логіки** для 61.1 у `fetchDeclarationDetail` і `fetchDeclarationDetails` (майже однаковий код оновлення `xmlData` + `updateDeclarationSummary`).
- `fetchDeclarationDetails(guids)` позначена як backward-compat і **не має support cancel**, але все одно може довго працювати і навантажувати систему.
- Є “захист” на випадок, якщо Prisma client не має моделей (`'syncHistory' in db`) — це ознака нестабільного процесу міграцій/генерації на проді.

#### Ризики (P1/P2)
- **P1:** Глобальні `process.on('unhandledRejection')` / `process.on('uncaughtException')` у server action файлі. Це може:
  - дублювати обробники між hot reload/різними ізольованими рантаймами,
  - засмічувати логи в проді.
  Тут зроблено guard `__mrnodeUnhandledHandlersInstalled`, але все одно краще тримати такі речі в одному “bootstrap” місці.
- **P2:** `await new Promise(resolve => setTimeout(resolve, 1000))` у циклі може робити синк надто повільним на великих компаніях. Можна перейти на контроль паралелізму (конкурентність 2–3) з backoff.

#### Рекомендації
- **P1:** Винести спільний код 61.1 оновлення в одну helper-функцію (DRY) і ввести єдину точку правди для формату `xmlData`.
- **P1:** Стандартизувати процес Prisma migrations/generate на Render так, щоб не доводилося робити `('syncHistory' in db)`.
- **P2:** Додати керований паралелізм + retry/backoff в `CustomsService` (або навколо нього).

---

### 6.2 Компанії та доступи: `src/actions/companies.ts`

#### Сильні сторони
- Базовий доступ перевіряється через сесію (`auth()`), і часто через таблицю `UserCompany`.
- Є **soft-delete компаній** (`deletedAt`) і фільтрація видалених компаній в `getUserCompanies`.
- При створенні/відновленні компанії:
  - токен **шифрується** (`encrypt(customsToken)`)
  - пишеться **аудит** (`CompanyAuditLog`)
  - виставляється `activeCompanyId`
- Валідація `edrpou` (8 цифр) — базово ок.

#### Слабкі сторони / ризики (P1)
- **P1:** У ряді функцій є fallback “знайти userId по email”, якщо `session.user.id` порожній. Це натякає на нестабільне наповнення сесії/типів. Краще забезпечити, щоб `session.user.id` завжди був присутній.
- **P1:** Логіка ролей у `UserCompany` (OWNER/MEMBER/VIEWER) є, але треба переконатися, що **всі критичні операції** (видалення компанії, інвайти, зміна ролей, налаштування токена) скрізь мають перевірку ролі.

#### Рекомендації
- **P1:** Перевірити й уніфікувати перевірки ролей у всіх company-діях (ввести helper `requireCompanyRole(...)`).
- **P2:** Додати схему валідації (Zod) для всіх входів (не тільки `edrpou`).

---

### 6.3 Аналітика дашборду: `src/actions/analytics.ts`

#### Сильні сторони
- Є кешування статистики для дефолтного перегляду (`statistics-cache`).
- Використовується `DeclarationSummary.aggregate` для метрик (правильно).
- Є фільтрація по мультикомпаніям з `checkCompanyAccess`.
- Є логіка по EE-деклараціям через налаштування компанії (toggle `showEeDeclarations`).

#### Слабкі сторони / ризики (P1)
- **P1 (продуктивність):** Після агрегатів робиться `db.declaration.findMany({ where, ... })` без `take`/обмеження і з `orderBy: { date: 'desc' }`. На великій компанії це може:
  - завантажити дуже багато рядків,
  - забити памʼять/час відповіді.
  Хоча select мінімальний, але кількість рядків — основна проблема.

#### Рекомендації
- **P1:** Для трендів/топів перейти на `groupBy`/`aggregate`/`queryRaw` по БД замість завантаження всіх декларацій у памʼять.
- **P2:** Ввести ліміт періоду або server-side sampling для трендів.

---

### 6.4 Debug API: `src/app/api/debug/access/route.ts`

#### Знахідка
- Endpoint дозволяє доступ тільки для `test@gmail.com`.

#### Ризик (P1)
- **P1:** Наявність debug endpoint у проді — це поверхня атаки/витоку. Навіть якщо email обмежений, можливі:
  - помилки конфігурації,
  - використання тестового акаунта,
  - витік зайвої діагностики.

#### Рекомендація
- **P1:** Вимкнути `src/app/api/debug/*` в production (через `NODE_ENV` guard) або перевести доступ на роль `ADMIN`.

---

### 6.5 Доступи до компаній (shared logic): `src/lib/company-access.ts`

#### Сильні сторони
- `activeCompanyId` береться **з БД**, а не з сесії (сесія може бути застарілою).
- Є логіка fallback:
  - якщо `activeCompanyId` не встановлено — береться перша активна компанія і записується в БД
  - якщо активна компанія недоступна/видалена — шукається альтернативна

#### Слабкі сторони / ризики
- **P1:** Дублюється патерн “якщо немає `session.user.id`, знайти userId по email” (так само як в `companies.ts`). Це симптом того, що типи/сесія не гарантовано містять `id`.
- **P2:** Багато DB запитів на один виклик (особливо fallback сценарії). На великому навантаженні може бути зайвим.

#### Рекомендації
- **P1:** Забезпечити, щоб `session.user.id` завжди був встановлений (і прибрати fallback-логіку пошуку по email, або залишити її тільки як тимчасовий guard).
- **P2:** Розглянути кешування/батчинг де можливо (але обережно, бо `activeCompanyId` має бути актуальним).

---

### 6.6 Криптографія (шифрування токена митниці): `src/lib/crypto.ts`

#### Критичний ризик (P0)
- **P0:** Є fallback ключа шифрування:
  - `process.env.ENCRYPTION_KEY || 'mrnode-local-mvp-secret-key-32-bytes!!'`

Ризик:
- У продакшні можна випадково запуститися з дефолтним ключем, що робить `customsToken` компрометованим.

Рекомендації:
- **P0:** Прибрати fallback у production (аналогічно до `AUTH_SECRET`).
- **P1:** Додати ротацію ключа (опційно): підтримка кількох ключів для decrypt (current + previous).
- **P2:** Перейти на AEAD (наприклад `aes-256-gcm`) замість CBC для кращої крипто-гігієни (CBC без MAC не дає цілісності).

---

### 6.7 Інтеграція з API митниці: `src/lib/customs-api.ts`

#### Сильні сторони
- Є явна обробка кодувань (win1251/utf8) та боротьба з “кракозябрами”.
- Підтримка ZIP (`adm-zip`) і декодування (`iconv-lite`) — практично необхідно для цього домену.

#### Критичні ризики (P0)
- **P0:** `https.Agent({ rejectUnauthorized: false })` — повністю вимикає перевірку SSL сертифікатів.

Ризик:
- MITM атаки (перехоплення токена, підміна відповідей).

Рекомендації:
- **P0:** Увімкнути перевірку сертифікатів у production.
  - Якщо митниця має проблемний сертифікат — краще додати їх CA/сертифікат як довірений, а не вимикати валідацію.
- **P1:** Додати таймаути/ретраї для axios на рівні клієнта (якщо їх ще нема нижче в файлі).
- **P2:** Винести “fixDoubleEncoding” в окремий, тестований модуль і покрити юніт-тестами на типових кейсах.

---

### 6.8 Синхронізація курсів валют: `src/app/api/exchange-rates/sync/route.ts`

#### Ризик (P1)
- **P1:** Endpoint не має явної авторизації/обмеження доступу. Якщо він доступний публічно — будь-хто може тригерити масовий sync.

#### Рекомендації
- **P1:** Обмежити доступ:
  - або тільки `ADMIN`
  - або секретний cron token
  - або дозволити тільки з внутрішньої мережі/Render cron.

---

### 6.10 Архів декларацій: UI/експорт/продуктивність

#### Ключові файли
- UI: `src/app/dashboard/archive/page-client.tsx`
- Експорт: `src/app/dashboard/archive/export-utils.ts`
- Хуки: `src/app/dashboard/archive/hooks/*`
- API для підтягування xml: `src/app/api/declarations/[id]/route.ts`

#### Сильні сторони
- **Серверна пагінація**: `page-client.tsx` запитує `getDeclarationsPaginated(currentPage, itemsPerPage, ...)`, тобто не вантажить “все і одразу”. Це правильний напрямок.
- Фільтри list61 реалізовані як “панель/дровер”, на мобільному є окремий drawer — UX адекватний.
- Для list61 видно прагнення **не тягнути `xmlData`** в списку і працювати з денормалізованим `summary`/`hsCodes`.
- Розширений експорт має **прогрес-стан** (phase/current/total) і обмежену конкурентність підвантаження деталей.

#### Слабкі сторони / ризики

##### P1 (продуктивність): клієнтська статистика по всіх даних
Файл: `src/app/dashboard/archive/hooks/useArchiveStatistics.ts`
- Хук рахує статистику по `filteredDocs` на клієнті та має багато fallback-парсингу (в т.ч. regex-парсинг XML для list60).
- На великих наборах даних це ризик CPU/лагів у браузері.

Рекомендації:
- **P1:** Для list61 — робити статистику строго серверною (що вже частково зроблено через `getArchiveStatistics`), а клієнтський розрахунок тримати як fallback тільки для маленьких наборів.
- **P2:** Для list60 — уникати regex-парсингу XML у браузері (або робити це тільки точково/по запиту).

##### P1 (продуктивність/навантаження): розширений експорт тягне xml через HTTP по одному документу
Файл: `src/app/dashboard/archive/export-utils.ts`
- `exportExtendedGoodsToExcel` / `enrichDocsWith61Details` викликає `/api/declarations/{id}` для кожного документа.
- Є конкурентність (`concurrency = 5`), але все одно:
  - при 500+ деклараціях це 500 HTTP запитів
  - сервер буде віддавати `xmlData` (потенційно великий), що впливає на трафік/час/памʼять.

Рекомендації:
- **P1:** Додати server-side endpoint “batch export details” (наприклад POST з масивом `ids`, який віддає мінімально потрібне, або генерує Excel на сервері).
- **P2:** Додати rate-limit/обмеження загальної кількості документів для “розширеного експорту” за один раз.

##### P1 (операційний ризик): видалення за період
Файли:
- `src/app/dashboard/archive/components/archive-modals/delete-period-modal.tsx`
- `src/app/dashboard/archive/hooks/useArchiveDelete.ts`

Ризик:
- Це дуже “сильна” операція. Є `confirm()` — добре, але бажано мати додатковий захист (особливо для великих компаній):
  - повторне підтвердження з введенням слова
  - логування в аудит
  - обмеження по ролі (OWNER/MEMBER)

Рекомендації:
- **P1:** Перевірити на сервері, що операції delete виконуються тільки для `OWNER/MEMBER` і для активної/доступної компанії.
- **P2:** Додати аудит-лог запис при масових delete.

---

## 7) Консолідований список рекомендацій (P0/P1/P2)

Цей розділ написаний так, щоб інший агент міг виконувати роботу **без додаткового контексту**.
Для кожного пункту є: **ризик**, **де в коді**, **що зробити**, **критерій готовності**.

### P0 (терміново) — безпека продакшну / секрети / транспорт

1) **P0: Прибрати дефолтний ключ шифрування `ENCRYPTION_KEY`**
- **Ризик:** якщо `ENCRYPTION_KEY` не встановлений у production, токени митниці шифруються відомим дефолтним ключем → компрометація даних.
- **Де:** `src/lib/crypto.ts` (`process.env.ENCRYPTION_KEY || 'mrnode-local-mvp-secret-key-32-bytes!!'`).
- **Що зробити:**
  - Заборонити запуск у production без `ENCRYPTION_KEY` (throw/error під час старту або під час першого encrypt/decrypt).
  - Дозволити fallback лише в `NODE_ENV !== 'production'`.
- **Критерій готовності:**
  - У production без `ENCRYPTION_KEY` апка не стартує (або всі операції з токеном повертають чітку помилку).
  - У dev fallback працює як зараз.
 - **Статус:** ✅ виконано
 - **Примітка:** додано guard в `src/lib/crypto.ts` (production вимагає `ENCRYPTION_KEY`). Проведено одноразову міграцію `company.customsToken` (перешифрування на новий ключ) через скрипт `migrate-customs-token-encryption.js`.

2) **P0: Увімкнути перевірку SSL сертифікатів для API митниці**
- **Ризик:** `rejectUnauthorized: false` дозволяє MITM (перехоплення токена, підміна відповідей API).
- **Де:** `src/lib/customs-api.ts` (`https.Agent({ rejectUnauthorized: false })`).
- **Що зробити:**
  - У production: `rejectUnauthorized: true`.
  - Якщо митниця реально має некоректний ланцюжок: додати довірений CA/сертифікат (pin/CA bundle), а не вимикати валідацію.
- **Критерій готовності:**
  - На production-збірці SSL валідація увімкнена.
  - Є документований спосіб/конфіг (env) для довірених CA, якщо потрібно.
 - **Статус:** ✅ виконано
 - **Примітка:** у `src/lib/customs-api.ts` увімкнено перевірку SSL сертифікатів (`rejectUnauthorized: true`).

3) **P0: Прибрати fallback `DATABASE_URL` у проді**
- **Ризик:** випадкове підключення до неправильної БД або небезпечні дефолти.
- **Де:** `src/lib/db.ts`.
- **Що зробити:**
  - Прибрати будь-які hardcoded/fallback значення `DATABASE_URL` (включно з локальними connection strings).
  - Якщо `DATABASE_URL` відсутній — процес має падати з явною помилкою (і в production, і в dev).
- **Критерій готовності:**
  - Без `DATABASE_URL` процес падає з явною помилкою.
 - **Статус:** ✅ виконано
 - **Примітка:** у `src/lib/db.ts` прибрано fallback та зроблено обовʼязковим `DATABASE_URL` (процес падає з помилкою, якщо змінна не задана). Також прибрано локальні connection strings з допоміжних файлів.

4) **P0: Закрити/вимкнути debug/admin endpoints у production**
- **Ризик:** зайва поверхня атаки та потенційний витік діагностичних даних.
- **Де:**
  - `src/app/api/debug/access/route.ts`
  - `src/app/api/exchange-rates/sync/route.ts` (публічний sync без auth)
- **Що зробити:**
  - Вимкнути debug API у production через `NODE_ENV` guard.
  - Для `exchange-rates/sync`: додати auth (ADMIN/cron secret).
- **Критерій готовності:**
  - У production не можна викликати debug endpoints.
  - `exchange-rates/sync` повертає 401/403 без авторизованого доступу.
 - **Статус:** ✅ виконано
 - **Примітка:** debug endpoint фактично вимкнено (повертає 404). Для `GET /api/exchange-rates/sync` додано обовʼязковий секрет `EXCHANGE_RATES_SYNC_SECRET` (Bearer token або query `?secret=`), щоб endpoint не можна було викликати публічно; рекомендовано запускати через Render Cron.

### P1 (важливо) — контроль доступу, продуктивність, стабільність

1) **P1: Уніфікувати перевірки доступу/ролей до компанії**
- **Ризик:** розрізнені перевірки в різних місцях → шанс пропустити контроль доступу.
- **Де:**
  - `src/actions/companies.ts`
  - `src/actions/sync.ts`
  - `src/lib/company-access.ts`
- **Що зробити:**
  - Ввести helper на рівні `lib` (наприклад `requireActiveCompanyRole(['OWNER','MEMBER'])`) і використовувати його для критичних дій.
  - Виправити/стандартизувати `session.user.id`, щоб не було постійних fallback “знайти по email”.
- **Критерій готовності:**
  - Усі критичні server actions/API (sync, delete, backfill, settings token) мають однаковий патерн перевірки ролей.
 - **Статус:** ✅ виконано
 - **Примітка:** додано/уніфіковано helper-и в `company-access.ts` (`requireActiveCompanyAccess`, `requireActiveCompanyFullAccess`, `checkCompanyAccess`, `filterAllowedCompanyIds`), критичні дії переведені на єдиний патерн; smoke-тести пройдені.

2) **P1: Обмежити важкі операції (exchange-rates sync / backfill-hscodes / масові delete)**
- **Ризик:** DDoS/випадкове перевантаження системи одним користувачем.
- **Де:**
  - `src/app/api/exchange-rates/sync/route.ts`
  - delete actions у `src/actions/declarations` (викликаються з архіву)
- **Що зробити:**
  - Додати rate limit/чергу/job-runner для довгих задач.
  - Додати аудит-лог для масових операцій.
- **Критерій готовності:**
  - Неможливо нескінченно тригерити важкі задачі без обмежень.
  - Є спостережуваність (лог/історія виконань).
 - **Статус:** ✅ виконано
 - **Примітка:**
   - `backfill-hscodes` видалено (API route та тимчасовий UI).
   - Для масових delete додано/є lock + operation log.
   - Для `exchange-rates/sync` додано lock + operation log; для “ледачого” підтягування курсів додано dedupe lock по даті в `src/actions/exchange-rates.ts` без обмеження послідовних викликів (щоб не ламати розширений експорт).

3) **P1: Аналітика/архів — уникати “витягнути все і порахувати в JS”**
- **Ризик:** високий час відповіді/памʼять, лаги UI на великих компаніях.
- **Де:**
  - `src/actions/analytics.ts` (після агрегатів робиться `findMany` без `take`)
  - `src/app/dashboard/archive/hooks/useArchiveStatistics.ts` (клієнтський розрахунок + XML regex)
- **Що зробити:**
  - Перенести топи/тренди на DB `groupBy/aggregate`.
  - Для архів-статистики list61: сервер — джерело правди, клієнтський fallback тільки для малих наборів.
- **Критерій готовності:**
  - На великих компаніях немає масових `findMany` без ліміту.
  - UI не підвисає при відкритті архіву.
 - **Статус:** ⏸️ відкладено (актуально)
 - **Поточний стан:**
   - `getDashboardAnalytics` вже рахує основні метрики через DB aggregate, але для топів/трендів все ще може витягувати багато декларацій (без `take`) і рахувати в JS.
   - В архіві частина статистики вже серверна (через actions + cache), але є клієнтський розрахунок з fallback-парсингом (в т.ч. regex по XML для list60), що на великих наборах може вантажити браузер.
 - **Пропозиція (коли будемо робити):**
   - Перенести топи/тренди в SQL (`groupBy/aggregate` + `orderBy` + `limit`) з тим самим `WHERE`, щоб зберегти семантику "по всіх деклараціях" та "по всіх відфільтрованих".
   - Для архіву: зробити сервер джерелом правди для list61, а клієнтський fallback лишити тільки для малих наборів.

4) **P1: Розширений експорт — прибрати N HTTP запитів `/api/declarations/{id}`**
- **Ризик:** 500+ декларацій → 500 HTTP запитів + великий трафік `xmlData`.
- **Де:** `src/app/dashboard/archive/export-utils.ts` (`fetchDeclarationXmlData`, `enrichDocsWith61Details`).
- **Що зробити:**
  - Додати server-side batch endpoint або server-side генерацію Excel.
  - Віддавати мінімально потрібні поля, а не весь `xmlData`, де можливо.
- **Критерій готовності:**
  - Експорт 500 документів робиться 1–5 запитами, а не сотнями.
 - **Примітка:** додано кнопку "Скасувати експорт" для розширеного експорту (AbortController), щоб користувач міг зупинити випадково запущений процес і продовжити роботу.

### P2 (покращення) — чистота коду, UX, тестованість

1) **P2: DRY для 61.1 оновлення (sync)**
- **Де:** `src/actions/sync.ts` (`fetchDeclarationDetail` vs `fetchDeclarationDetails`).
- **Що зробити:** винести в helper спільний код збереження `xmlData`/`updateDeclarationSummary`.
- **Критерій:** одна реалізація шляху оновлення 61.1.
 - **Rollback commit (якщо щось зламається під час чистки P2.1):** `47dc431`
 - **Впроваджено (чистка варіанту C):** `cbae457`
 - **Статус перевірки:**
   - Автотести: ✅ `npx vitest run` пройшли.
   - Manual QA: ✅ пройшло (ручні тести виконані, проблем не виявлено).
 - **Як перевірити вручну (чекліст):**
   - **[Синхронізація / 61.1 вручну]** Відкрити `/dashboard/sync`.
   - **[Список без деталей]** Натиснути оновлення списку “без 61.1” (якщо є кнопка/дія в UI) і переконатись, що список завантажується без помилок.
   - **[Оновлення вибраних]** Обрати 1–3 GUID та запустити завантаження деталей 61.1.
   - **[Результат]** Після завершення:
     - Перевірити, що елементи зникли зі списку “без деталей” (або зменшилась кількість).
     - Відкрити `/dashboard/archive` та переконатись, що для цих декларацій відображаються деталі (товари/поля 61.1) і статистика рахується коректно.
   - **[Cancel]** Запустити завантаження деталей для 10–20 GUID та натиснути “Скасувати” під час процесу.
     - Очікування: процес зупиняється, UI не зависає, частково оброблені декларації залишаються коректними.
   - **[Повторний запуск]** Після cancel повторно запустити завантаження — має продовжити з решти.
   - **[Full-period sync]** (якщо використовується) Запустити `syncAllPeriod`/staged і переконатись, що стадії 60.1/61.1 проходять, статус job оновлюється, а `/dashboard/archive` після завершення показує оновлені дані.

2) **P2: Крипто-гігієна**
- **Де:** `src/lib/crypto.ts`.
- **Що зробити:** перейти на AEAD (`aes-256-gcm`) та (опційно) підтримати ротацію ключів.
- **Критерій:** шифрування з цілісністю, зрозумілий план ротації.
 - **Поточний стан:** використовується `aes-256-cbc` без автентичності/тега (формат `iv:cipher`), що не дає криптографічної гарантії цілісності ciphertext.
 - **Пропозиція:** додати `v2:` формат на `aes-256-gcm` (AEAD) з backward-compatible `decrypt()` для старого CBC, після чого виконати масову міграцію `Company.customsToken` у формат `v2:`.

3) **P2: Поліпшити UX масових delete**
- **Де:** архів (delete модалка + server action).
- **Що зробити:** друге підтвердження (ввести слово), ліміти періоду/кількості.
- **Критерій:** менший ризик випадкового видалення.

## 8) Журнал змін цього звіту
- 2026-01-31: створено файл, додано первинні висновки (A+B), зафіксовано P0 ризики по секретах/DB URL.
- 2026-01-31: додано поглиблений аналіз `sync.ts`, `companies.ts`, `analytics.ts`, debug API, з новими P1 рекомендаціями.
- 2026-01-31: додано аналіз `company-access.ts`, `crypto.ts`, `customs-api.ts`, `api/admin/backfill-hscodes`, `api/exchange-rates/sync`.
- 2026-01-31: додано аналіз модуля архіву (UI/статистика/експорт/видалення) з фокусом на продуктивність та safety rails.
- 2026-01-31: додано консолідований список рекомендацій P0/P1/P2 з критеріями готовності.
