# План оптимізації продуктивності архіву

## Проблема
- Завантаження 6600 декларацій займає ~20 секунд
- Всі дані завантажуються одразу з БД
- Парсинг XML для всіх записів на клієнті
- Фільтрація/сортування на клієнті
- Завантаження `summary` для всіх записів

## Рішення

### 1. Server-Side Pagination (Пріоритет: ВИСОКИЙ)
**Що робити:**
- Завантажувати тільки потрібну сторінку з БД (наприклад, 20-50 записів)
- Використовувати `skip` та `take` в Prisma
- Завантажувати загальну кількість записів окремим запитом (`count`)

**Переваги:**
- Швидше завантаження (тільки потрібні дані)
- Менше навантаження на БД
- Менше передача даних через мережу
- Швидший перший рендер

**Реалізація:**
```typescript
// src/actions/declarations.ts
export async function getDeclarationsPaginated(
  page: number = 1,
  pageSize: number = 20,
  filters?: FilterOptions,
  sortBy?: string,
  sortOrder?: 'asc' | 'desc'
) {
  const skip = (page - 1) * pageSize;
  
  const where = buildWhereClause(filters);
  
  const [declarations, total] = await Promise.all([
    db.declaration.findMany({
      where,
      skip,
      take: pageSize,
      orderBy: buildOrderBy(sortBy, sortOrder),
      // Не завантажувати summary за замовчуванням
      include: {
        summary: false // або тільки коли потрібно
      }
    }),
    db.declaration.count({ where })
  ]);
  
  return { declarations, total, page, pageSize };
}
```

### 2. Server-Side Filtering (Пріоритет: ВИСОКИЙ)
**Що робити:**
- Застосовувати фільтри в SQL запиті
- Використовувати індекси БД для швидкого пошуку
- Фільтрувати по полях, які є в БД (date, status, customsOffice тощо)

**Переваги:**
- БД виконує фільтрацію швидше
- Менше даних передається на клієнт
- Менше обробки на клієнті

**Реалізація:**
```typescript
function buildWhereClause(filters: FilterOptions) {
  const where: any = {
    companyId: user.company.id
  };
  
  if (filters.dateFrom) {
    where.date = { ...where.date, gte: new Date(filters.dateFrom) };
  }
  if (filters.dateTo) {
    where.date = { ...where.date, lte: new Date(filters.dateTo) };
  }
  if (filters.status !== 'all') {
    where.status = filters.status;
  }
  if (filters.customsOffice) {
    // Потрібно буде додати поле customsOffice в Declaration модель
    // або фільтрувати через summary
  }
  
  return where;
}
```

### 3. Server-Side Sorting (Пріоритет: ВИСОКИЙ)
**Що робити:**
- Сортувати в SQL запиті
- Використовувати індекси БД для швидкого сортування

**Переваги:**
- БД виконує сортування швидше
- Менше обробки на клієнті

### 4. Lazy Loading XML Parsing (Пріоритет: СЕРЕДНІЙ)
**Що робити:**
- Парсити XML тільки для видимих записів
- Використовувати віртуалізацію для парсингу
- Кешувати оброблені дані

**Переваги:**
- Швидший перший рендер
- Менше обробки на клієнті

**Реалізація:**
```typescript
// Парсити тільки видимі записи
const visibleItems = virtualItems.map(virtualRow => {
  const doc = sortedDocs[virtualRow.index];
  // Парсити XML тільки для видимих записів
  return parseXmlData(doc);
});
```

### 5. Оптимізація завантаження Summary (Пріоритет: СЕРЕДНІЙ)
**Що робити:**
- Не завантажувати `summary` за замовчуванням
- Завантажувати `summary` тільки коли потрібно (наприклад, для list61)
- Використовувати `select` для вибіркового завантаження полів

**Переваги:**
- Менше даних з БД
- Швидше завантаження

### 6. Кешування оброблених даних (Пріоритет: НИЗЬКИЙ)
**Що робити:**
- Кешувати оброблені дані в пам'яті або localStorage
- Використовувати React Query або SWR для кешування

**Переваги:**
- Швидший доступ до даних
- Менше обробки

### 7. Оптимізація індексів БД (Пріоритет: ВИСОКИЙ)
**Що робити:**
- Додати індекси на часто використовувані поля:
  - `companyId`
  - `date`
  - `status`
  - `customsId` (GUID)
  - `mrn`

**Переваги:**
- Швидші запити до БД
- Швидше фільтрація та сортування

## План впровадження

### Етап 1: Server-Side Pagination (найбільший ефект)
1. Створити `getDeclarationsPaginated` функцію
2. Оновити `page.tsx` для використання пагінації
3. Оновити `page-client.tsx` для роботи з пагінацією
4. Тестувати з великою кількістю даних

### Етап 2: Server-Side Filtering
1. Створити `buildWhereClause` функцію
2. Додати поля в БД для фільтрації (якщо потрібно)
3. Оновити фільтри для роботи з сервером
4. Тестувати фільтрацію

### Етап 3: Server-Side Sorting
1. Створити `buildOrderBy` функцію
2. Оновити сортування для роботи з сервером
3. Тестувати сортування

### Етап 4: Оптимізація індексів
1. Додати індекси в Prisma schema
2. Запустити міграцію
3. Тестувати швидкість запитів

### Етап 5: Lazy Loading XML Parsing
1. Оновити `useArchiveData` для lazy parsing
2. Використовувати віртуалізацію для парсингу
3. Тестувати продуктивність

## Очікувані результати

### До оптимізації:
- Завантаження: ~20 секунд для 6600 записів
- Перший рендер: ~20 секунд
- Переходи між сторінками: повільні

### Після оптимізації:
- Завантаження: ~1-2 секунди (тільки перша сторінка)
- Перший рендер: ~1-2 секунди
- Переходи між сторінками: миттєві
- Загальна продуктивність: покращення в 10-20 разів

## Додаткові рекомендації

1. **Debouncing для пошуку**: Затримка перед виконанням запиту
2. **Prefetching**: Завантажувати наступну сторінку заздалегідь
3. **Virtual scrolling**: Вже є, але потрібно оптимізувати
4. **Code splitting**: Розділити код на chunks для швидшого завантаження
5. **Image optimization**: Якщо є зображення, оптимізувати їх

## Реалізовано: Server-Side Кешування Статистики ✅

### Що зроблено:
1. **Створено server-side кеш статистики** (`src/lib/statistics-cache.ts`)
   - In-memory кеш на сервері
   - Кешується на рівні company
   - TTL: 30 хвилин

2. **Оновлено `getDashboardAnalytics()`**
   - Використовує кешовані дані якщо доступні
   - Обчислює статистику тільки при першому запиті або після інвалідації
   - Зберігає результат в кеш

3. **Інвалідація кешу після синхронізації**
   - Кеш автоматично очищається після завершення синхронізації
   - Статистика оновлюється тільки коли є нові дані

### Переваги:
- ✅ Швидший дашборд: не потрібно обчислювати статистику при кожному відкритті
- ✅ Менше навантаження на БД: статистика обчислюється один раз
- ✅ Автоматичне оновлення: кеш очищається після синхронізації
- ✅ Статистика залишається актуальною: оновлюється тільки коли є нові дані

### Для архіву:
- Клієнтське кешування вже реалізовано в `useArchiveStatistics`
- Статистика буде обчислюватись швидше завдяки майбутній server-side пагінації

## Реалізовано: Server-Side Pagination, Filtering, Sorting ✅

### Що зроблено:

1. **Server-Side Pagination** (`getDeclarationsPaginated`)
   - ✅ Завантаження тільки потрібної сторінки (20-50 записів замість 6600)
   - ✅ Використання `skip` та `take` в Prisma
   - ✅ Паралельне обчислення `count` для загальної кількості

2. **Server-Side Filtering**
   - ✅ Фільтрація на рівні БД (status, date, customsOffice, currency, consignor, consignee, declarationType, searchTerm)
   - ✅ Фільтри застосовуються в SQL запиті
   - ✅ Використання індексів БД для швидкого пошуку

3. **Server-Side Sorting**
   - ✅ Сортування на рівні БД
   - ✅ Підтримка різних колонок (mdNumber, registeredDate, status, type, consignor, consignee, invoiceValue, goodsCount)

4. **Оптимізація завантаження Summary**
   - ✅ Завантаження `summary` тільки коли потрібно (для list61 або коли використовуються фільтри)

5. **Кешування архівної статистики**
   - ✅ Кешування статистики з унікальним ключем (companyId + tab + filters)
   - ✅ Збільшено ліміт до 50 000 записів
   - ✅ TTL: 30 хвилин
   - ✅ Автоматична інвалідація після синхронізації

6. **Індекси БД**
   - ✅ Додано індекси на `companyId`, `status`, `date`, `customsId`, `mrn`
   - ✅ Композитні індекси: `(companyId, status)`, `(companyId, date)`
   - ✅ Швидший пошук та фільтрація

7. **URL параметри для фільтрів**
   - ✅ Всі фільтри та пагінація синхронізовані з URL
   - ✅ Можливість поділитись посиланням з фільтрами
   - ✅ Debouncing для пошуку (500ms) та фільтрів (300ms)

### Очікувані результати:
- ✅ Завантаження: з ~20 секунд до ~1-2 секунд (покращення в 10-20 разів)
- ✅ Перший рендер: з ~20 секунд до ~1-2 секунд
- ✅ Переходи між сторінками: миттєві
- ✅ Статистика: швидка завдяки кешуванню
- ✅ Фільтри: працюють на рівні БД (швидко)

### Виправлено:
- ✅ Помилка `localStorage is not defined` на сервері
- ✅ Статистика відображається для всіх декларацій (не тільки поточна сторінка)
- ✅ Топ-10 контрактотримачів відображається правильно
- ✅ Топ-10 кодів УКТЗЕД відображається правильно
